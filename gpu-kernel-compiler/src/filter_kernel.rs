//! Typed Rust wrapper for the GPU filter (selection) kernel.
//!
//! The kernel writes a `u8` bitmask (`1` = pass, `0` = filtered out) for each
//! row.  A second compaction pass (prefix-sum + scatter) then materialises
//! only the passing rows.

use anyhow::Result;
use cudarc::driver::CudaDevice;
use std::sync::Arc;
use tracing::{debug, info};

pub struct FilterKernel {
    device: Arc<CudaDevice>,
}

/// Parameters required to launch the filter kernel.
pub struct FilterParams {
    /// GPU pointer to the (flat) column data (int64 layout assumed).
    pub column_ptr: u64,
    /// Number of rows.
    pub n_rows: u64,
    /// GPU pointer where the u8 bitmask will be written.
    pub out_mask_ptr: u64,
    /// CUDA grid dimension.
    pub grid_dim: u32,
    /// CUDA block dimension.
    pub block_dim: u32,
}

impl FilterKernel {
    pub fn new(device: Arc<CudaDevice>) -> Result<Self> {
        info!("FilterKernel: initialised (runtime PTX codegen path)");
        Ok(Self { device })
    }

    /// Launch the filter kernel described by `ptx` (generated by
    /// [`crate::codegen::KernelCodegen::emit_filter_ptx`]).
    ///
    /// In a real build the PTX is loaded into the driver via `cuModuleLoadData`
    /// and the kernel launched with `cuLaunchKernel`.  Here we expose the
    /// full wiring so the rest of the engine can call into it.
    pub fn launch(&self, ptx: &str, params: FilterParams) -> Result<()> {
        debug!(
            "FilterKernel::launch rows={} grid={} block={}",
            params.n_rows, params.grid_dim, params.block_dim
        );

        // ----------------------------------------------------------------
        // REAL IMPLEMENTATION (requires a live CUDA device):
        //
        //   let module = self.device.load_ptx(ptx.into(), "filter_kernel", &["filter_kernel"])?;
        //   let f = module.get_func("filter_kernel")?;
        //   unsafe {
        //       self.device.launch_kernel(
        //           &f,
        //           [params.grid_dim, 1, 1],
        //           [params.block_dim, 1, 1],
        //           0,   // shared memory bytes
        //           (params.column_ptr, params.out_mask_ptr, params.n_rows),
        //       )?;
        //   }
        //   self.device.synchronize()?;
        //
        // ----------------------------------------------------------------

        info!(
            "FilterKernel: would launch {} rows (PTX {} bytes)",
            params.n_rows,
            ptx.len()
        );
        Ok(())
    }

    /// Convenience: compute the optimal (grid, block) pair for `n_rows`.
    pub fn compute_launch_params(n_rows: u64) -> (u32, u32) {
        const BLOCK: u32 = 256;
        let grid = ((n_rows as u32) + BLOCK - 1) / BLOCK;
        (grid.max(1), BLOCK)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn launch_params() {
        let (g, b) = FilterKernel::compute_launch_params(1024);
        assert_eq!(g, 4);
        assert_eq!(b, 256);

        let (g, b) = FilterKernel::compute_launch_params(1);
        assert_eq!(g, 1);
        assert_eq!(b, 256);
    }
}
